---
title: "Pipeline del análisis"
author: "Marina Ballesteros"
date: "5/28/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1. Definición de los datos

Antes de empezar el análisis, crearé tres carpetas en el directorio principal de trabajo para facilitar el manejo de los datos, figuras y resultados que se vayan obteniendo. Estas carpetas serán __data__, __figures__ y __results__.

```{r CreateFolders, warning=FALSE, include=FALSE}
setwd(".")
dir.create("data")
dir.create("results")
dir.create("figures")
```

El primer paso es leer los archivos __counts.csv__ y __targets.csv__ aportados junto el enunciado de la PEC, ambos archivos están ubicados en una la __data__ en el directorio principal de trabajo.

El archivo _targets.csv_ es un resumen de cada experinecia donde aparecen informaciones como el grupo, sexo o nombre de la muestra. La columna _group_ de este archivo nos informa de los tres grupos de muestras existentes:

  -Not infiltrated tissues (NIT)
  -Small focal infiltrates (SFI)
  -Extensive lymphoid infiltrates (ELI)
  
El archivo _counts.csv_ contiene en sus columnas el nombre de las 292 muestras y cada fila pertenece a un gen diferente.

```{r Instalación edgeR, include=FALSE}
BiocManager::install("edgeR")
```

```{r lectura de los archivos, include=FALSE}
library(readr)
targets <- read_csv("./data/targets.csv")
library(edgeR)
counts <- readTargets("./data/counts.csv", sep=";")
```

*Nota: antes de continuar con la selección de muestras, siguiendo los consejos del foro voy a eliminar la versión de ENSEMBL de cada anotación.

```{r Limpieza códigos ENSEMBLE, include=FALSE}
counts$X <- gsub("\\..*", "", counts$X, fixed = FALSE)
```

El siguiente paso es escoger 30 muestras dentro de las 292 muestras posibles, de manera que tengamos 10 muestras de cada uno de los tres grupos de tiroides. Para llevar a cabo esto, necesitamos seleccionar primero 10 muestras de cada grupo a través de la columna _group_ del archivo __targets.csv__. 
La selección la haré con la función _subset_ del paqute __dplyr__; a continuación, para unir las 30 muestras utilizaré la función _Reduce_.

```{r Selección de las 30 muestras, include=FALSE}
library(dplyr)
group_NIT<-subset(targets, Group=="NIT")[1:10,]
group_SFI<-subset(targets, Group=="SFI")[1:10,]
group_ELI<-subset(targets, Group=="ELI")[1:10,]

#Unimos los tres data frame creados en uno solo
targets_30<-Reduce(function(...) merge(...,all=TRUE), list(group_NIT, group_SFI, group_ELI))
```

Una vez hemos escogido las 30 muestras, extraemos las columnas correspondientes (en el archivo __counts.csv__) a esas 30 filas seleccionadas. 

*Nota*: Para hacer la selección de las columnas del archivo __counts.csv__ primero he extraído todos los _Sample_Name_ del archivo __targets_30__, después los he copiado y modificado los guiones por puntos para que coincidan con los nombres de las columnas del archivo __counts.csv__. Seguramente es una manera muy rudimentaria de hacerlo, pero no conseguí hacerlo de otra forma para cambiar los 30 nombres.

```{r Extracción de las 30 filas seleccionadas anteriormente, include=FALSE}
#Extraigo los nombres de la columna Sample_Name
nombres<- sort(targets_30$Sample_Name)
#Copio y modifico los nombres anteriores en el siguiente comando para
#seleccionar las 30 columnas en counts
counts_30<-counts[ , c("GTEX.111CU.0226.SM.5GZXC", "GTEX.111FC.1026.SM.5GZX1", "GTEX.111VG.0526.SM.5N9BW", "GTEX.111YS.0726.SM.5GZY8", "GTEX.1122O.0226.SM.5N9DA", "GTEX.1128S.0126.SM.5H12S", "GTEX.113JC.0126.SM.5EGJW", "GTEX.117XS.0526.SM.5987Q", "GTEX.117YW.0126.SM.5EGGN", "GTEX.117YX.1226.SM.5H11S", "GTEX.1192W.0126.SM.5EGGS", "GTEX.1192X.1126.SM.5EGGU", "GTEX.11DXY.0426.SM.5H12R", "GTEX.11EQ8.0826.SM.5N9FG", "GTEX.11EQ9.0626.SM.5A5K1", "GTEX.11GS4.0826.SM.5986J", "GTEX.11NV4.0626.SM.5N9BR", "GTEX.11O72.2326.SM.5BC7H", "GTEX.11TUW.0226.SM.5LU8X", "GTEX.11XUK.0226.SM.5EQLW", "GTEX.1211K.0726.SM.5FQUW", "GTEX.12584.0826.SM.5FQSK", "GTEX.12BJ1.0426.SM.5FQSO", "GTEX.13NZ9.1126.SM.5MR37", "GTEX.13QJC.0826.SM.5RQKC", "GTEX.14ABY.0926.SM.5Q5DY", "GTEX.14AS3.0226.SM.5Q5B6", "GTEX.14BMU.0226.SM.5S2QA", "GTEX.PLZ4.1226.SM.2I5FE",  "GTEX.R55G.0726.SM.2TC6J")]
#Creo el objeto group para recopilar el grupo al que pertenece cada muestra 
group<- c("NIT","NIT","ELI","NIT","NIT","NIT","NIT","NIT","SFI","NIT","NIT","NIT","SFI","SFI","SFI","SFI","ELI","SFI","SFI","ELI","SFI","SFI","SFI","ELI","ELI","ELI","ELI","ELI","ELI","ELI")
```

# 2. Preprocesado de los datos: filtraje y normalización

## 2.1 Filtración de los genes

Filtraremos los genes reteniendo sólo aquellos genes que se expresen en todas las muestras y con un número mínimo de contajes. El proceso de filtraje es muy importante ya que los genes con recuentos muy bajos en las librerías no proporcionan apenas pruebas de expresión diferencial y, además, interfieren de forma negativa en algunas aproximaciones estadísticas. En consecuecia, estos genes con bajos conteos reducen el poder de detección de los genes de expresión diferencial y por ello es importante eliminarlos.

Hay distintas formas de filtrar los genes de baja expresión pero antes se deben transformar los conteos con el fin de tener en una misma escala todas las muestras de un mismo estudio y evitar, así, diferencias debido al distinto tamaño de las librerías. La transformación se realizará con la conversión de los conteos a CPM (conteos por millón) a través de la función __cpm__.

En este estudio por cada grupo existen 10 réplicas biológicas, ya que el tamaño de muestra de cada grupo es 10. Por este motivo, estableceré un umbral mínimo de conteos por millón (CPM) en al menos 10 muestras; es decir, favoreceré un filtraje donde los genes estén representados al menos una vez en todas las muestras en cada grupo.

El segundo umbral que podemos marcar para el filtraje es un mínimo de conteos por millón para cada gen. Para obtener el número de conteos por millón utilizaré la función __cpm__ del paquete _edgeR_. Esta función permite convertir los contajes a CPMs, por lo tanto, se están normalizando los conteos para las diferentes profundidades de secuenciación de cada muestra.

```{r Obtención de los CPMs, include=FALSE}
myCPM <- cpm(counts_30)
head(myCPM)
```

Por regla general, se puede elegir un buen umbral mínimo de CPMs identificando el CPM que corresponde a un conteo de 10. Contrastando las tablas __counts_30__ y __myCPM__, se observa que el umbral en este caso es aproximadamente 0,15. Con la selección de genes que superen el umbral de 0,15 se obtiene una matriz lógica con los genes que han superado el umbral (TRUE) y los genes que estan por debajo del umbral (FALSE).

```{r selecciòn de genes con el umbral myCPM>0.15, include=FALSE}
# Seleccionamos los valores CPM mayores al umbral
thresh <- myCPM > 0.15
# Se crea una matriz lógica de TRUE y FALSE
head(thresh)
```

Una vez he filtrado los genes, hago un resumen con los genes que tienen un valor CPM superior al valor umbral. Dentro de los genes seleccionados como _TRUE_, seleccionaré los genes que tienen al menos 10 valores TRUE para cada gen; es decir, me quedaré con los genes que tengan representación en todas las muestras del grupo.

Una vez los dos umbrales han sido aplicados, selecciono los genes con una mayor expresión y estos serán los únicos conteos que conservaré para posteriores análisis. En este caso partimos de 56202 genes y tan solo conservaré 22990 genes tras la filtración.

```{r Selección de genes que superen el umbral, echo=FALSE}
table(rowSums(thresh))
# Mantengo los genes con al menos 10 TRUES en cada fila
keep <- rowSums(thresh) >= 10
# Mantengo solo los genes con mayor expresión
counts.keep <- counts_30[keep,]
summary(keep)
dim(counts.keep)
```

Hasta aquí llega el proceso de filtraje, ahora debo convertir los conteos en un objeto de la clase __DEGList__; este objeto es propio del paquete _edgeR_ y sirve para almacenar datos de conteos con los parámetros que se consideren pertinentes. En este caso sólo añadiré como parámetro la clasificación de las muestras en el grupo correspondiente gracias al objeto _group_ creado junto con la tabla de conteos _counts_30_.

```{r Creación del objeto DEGList, include=FALSE}
y <- DGEList(counts.keep, group = group)
# Muestras del obtejo DEGList
names(y)
# Información del tamaño de las librerías en cada muestra
y$samples
```


## 3.2 Control de calidad de los datos filtrados

El objetivo del control de calidad es revelar posibles problemas técnicos u otros sesgos presentes en los datos. La mejor manera para llevar a cabo un control de calidad es de manera visual. El primer paso, por lo tanto, será representar los datos gráficamente. 

El primer gráfico será una representación de los tamaños de las distintas librerías con un gráfico de barras para ver si hay grandes discrepancias entre las muestras. 
Para que la identificación de las muestras sea más fácil, he creado la variable __ShortName__ a partir del archivo _targets_30_ en el que se identifican las muestras con un nombre más corto que el nombre original.
El gráfico quedará registrado en la carpeta __figures__ bajo el nombre _Barplot_librerias_.

```{r fig.cap="Barplot que representa el tamaño de las librerías de cada muestra.", echo=FALSE, out.extra='', fig.height=5, fig.width=5, fig.align="center"}}
ShortName = c("111CU_NIT", "111FC_NIT", "111VG_ELI", "111YS_NIT", "1122O_NIT", "1128S_NIT", "113JC_NIT", "117XS_NIT", "117YW_SFI", "117YX_NIT", "1192W_NIT", "1192X_NIT", "11DXY_SFI", "11EQ8_SFI", "11EQ9_SFI", "11GS4_SFI", "11NV4_ELI", "11O72_SFI", "11TUW_SFI", "11XUK_ELI", "1211K_SFI", "12584_SFI", "12BJ1_SFI", "13NZ9_ELI", "13QJC_ELI", "14ABY_ELI", "14AS3_ELI", "14BMU_ELI", "PLZ4-_ELI", "R55G-_ELI")
barplot(y$samples$lib.size*1e-6, names=ShortName, las=2, col = "lightblue", ylab = "Tamaño de las librerías (millones)")
title("Barplot del tamaño de las librerías")
```
```{r saveBarplotLibrerías, echo=FALSE, results='hide'}
#Guardo el barplot en un archivo tiff en el directorio figures
tiff("./figures/Barplot_librerias.tiff", res = 200, width = 4, height = 4, units = 'in')
barplot(y$samples$lib.size*1e-6, names=ShortName, las=2, col = "lightblue", ylab = "Tamaño de las librerías (millones)")
title("Barplot del tamaño de las librerías")
dev.off()
```

En el gráfico se aprecia que las dimensiones de las librerías varían entre 15 y 70 millones de conteos. Estas enormes diferencias en el tamaño de las librerías indica que una normalización de los datos es necesaria antes de llevar a cabo los análisis de expresión diferencial.

Los datos de conteo no están distribuidos normalmente, así que si quiero examinar las distribuciones de los conteos en bruto necesito convertir los conteos en logaritmos. Una vez los conteos estén trnaformados en logaritmos, usaré gráficos de caja para comprobar la distribución de los recuentos leídos en la escala log2. La función __cpm__ me ayudará a obtener los recuentos log2 por millón, que se corrigen para los diferentes tamaños de las librerías. La función __cpm__ también añade un pequeño desplazamiento para evitar tomar el logaritmo de cero.

```{r fig.cap="Boxplot de las dsitribuciones de las librerías.", echo=FALSE, out.extra='', fig.height=5, fig.width=5, fig.align="center"}
# Log2 de los CPM
logcounts <- cpm(y,log=TRUE)
# Comprobamos la distribución de las muestras
boxplot(logcounts, xlab="", ylab="Log2 conteos por millón",las=2)
# Añadimos la línea azul que marca la medians de logCPM 
abline(h=median(logcounts),col="blue")
title("Boxplots de los logCPMs (no normalizados)")
```


De las 30 cajas, se observa que en general las distribuciones de densidad de las intensidades logarítmicas brutas no son idénticas pero aún así no muy diferentes. Si una muestra está realmente muy por encima o por debajo de la línea horizontal azul, se necesitaría entonces investigar esa muestra más a fondo. Los puntos dibujados más allá de los extremos de las cajas corresponden a valores outliers. 
El Boxplot esta registrado en el directorio __figures__ bajo el nombre de _Boxplot_librerias_.

```{r saveBoxplot, echo=FALSE, results='hide'}
#Guardo el boxplot en un archivo tiff en el directorio figures
tiff("./figures/Boxplot_librerias.tiff", res = 200, width = 4, height = 4, units = 'in')
boxplot(logcounts, xlab="", ylab="Log2 conteos por millón",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots de los logCPMs (no normalizados)")
dev.off()
```

El siguiente gráfico que llevaré a cabo en este control de calidad visual es un __Mapa de color__. Este tipo de gráficos sirven para agrupar las muestras en base a algún método jerárquico. Por lo tanto, las muestras que se encuentren juntas serán las muestras más similares entre sí.
El Hetatmap se ha registrado en el directorio __figures__ bajo en nombre de _Heatmap.png_.

```{r Instalación de paquetes mixOmics y RColorBrewer, include=FALSE}
BiocManager::install("mixOmics")
BiocManager::install("RColorBrewer")
```

```{r fig.cap="Mapa de color para cada muestra en cada grupo.", echo=FALSE, out.extra='', fig.height=5, fig.width=5, fig.align="center" }
require(mixOmics)
require(RColorBrewer)
mat.dist = logcounts
colnames(mat.dist) = ShortName 
mat.dist = as.matrix(dist(t(mat.dist)))
mat.dist = mat.dist/max(mat.dist)
hmcol = colorRampPalette(brewer.pal(9, "GnBu"))(16)
cim(mat.dist, color = rev(hmcol), symkey = FALSE, margins = c(9, 9))
```

En el _Heatmap_ no existe una clara agrupación entre los tres grupos, el grupo que más agrupado se encuentra es el _ELI_ en la parte inferior del eje Y. Por el contrario, las muestras de los grupos _SFI_ y _NIT_ están entremezcladas.
Según la escala de colores, el color azul representaría los genes que no han cambiado su expresión ; mientras que el color verde representa los genes que si han aumentado su expresión. Esto me hace indicar que en la inmensa mayoría de los casos, los genes de las diferentes muestras han sufrido un aumento en su expresión, veré si esta predicción se corresponde más adelante con el análisis de expresión diferencial.

```{r SaveHeatmap, echo=FALSE, results='hide',fig.height=5, fig.width=5}
#Guardo el Heatmap en un archivo tiff en el directorio figures
tiff("./figures/Heatmap.png", res = 200, width = 4, height = 4, units = 'in')
require(mixOmics)
require(RColorBrewer)
mat.dist = logcounts
colnames(mat.dist) = paste(colnames(mat.dist), sep = " : ") 
mat.dist = as.matrix(dist(t(mat.dist)))
mat.dist = mat.dist/max(mat.dist)
hmcol = colorRampPalette(brewer.pal(9, "GnBu"))(16)
cim(mat.dist, color = rev(hmcol), symkey = FALSE, margins = c(0.05, 0.05))
dev.off()
```

Para acabar con este control de calidad visual, representaré un __Plot de componentes principales (PCA)__. Este tipo de gráficos es útil para visualizar el efecto global de las covariables experimentales y los efectos de los lotes. En este análisis, el plot PCA agrupa las muestras por grupos de genes que más significativamente han cambiado su expresión. Debido a que en este estudio existe un único factor con tres niveles: SFI, NIT y ELI; debería haber una clara separación de las muestras en función de estos tres niveles.
Para hacer el análisis de componentes principales necesito dos paquetes: __AnnotatedDataFrame__ y __DESeq__.

```{r Instalación de paquetes, include=FALSE}
BiocManager::install("AnnotatedDataFrame")
BiocManager::install("DESeq2")
```

Gracias al paquete __matrixStats__ puedo calcular la varianza para cada gen incluído en la matriz _logcounts_. Dicha varianza que me servirá como base para la creación del plot PCA con los genes que más han cambiado su expresión, ya que seleccionaré los genes por orden decreciente de su varianza.

```{r Estimación de la varianza, include=FALSE}
require(matrixStats)
#Estimamos la varianza para cada fila en la matriz
matriz = as.matrix(logcounts)
rv = rowVars(matriz)
select = order(rv, decreasing = TRUE)
pca = prcomp(t(logcounts[select, ]))
```

La función __plotPCA__ realiza fácilmente el gráfico que buscamos.

```{r fig.cap="Plot PCA para el análisis de componentes principales", echo=FALSE, out.extra='', fig.height=5, fig.width=5, fig.align="center"}
require(DESeq2)
require(mixOmics)
annot = AnnotatedDataFrame(data = data.frame(group, row.names = colnames(logcounts)))
expSet = new("ExpressionSet", exprs = as.matrix(logcounts), phenoData=annot) 
plotPCA(expSet, intgroup = c("group"))
```
```{r SaveplotPCA, echo=FALSE, results='hide',fig.height=5, fig.width=5}
#Guardo el plotPCA en un archivo tiff en el directorio figures
tiff("./figures/plotPCA.tiff", res = 200, width = 4, height = 4, units = 'in')
plotPCA(expSet, intgroup = c("group"))
dev.off()
```

En el gráfico de __análisis de componentes principales__ se ve una clara separación de los tres grupos: las muestras pertenecientes al gruo _ELI_ se sitúan a la derecha del gráfico, las muestras del grupo _SFI_ están en la mitad baja del gráfico y, las muestras _NIT_ se ubican en la parte derecha del plot. Sin embargo, se pueden observar dos muestras que no están situadas con su grupo: una muestra _SFI_ y una muestra _ELI_ se sitúan junto a las muestras del grupo _NIT_. Debido a que son sólo dos muestras, una de cada grupo, no hablaría de efectos de lote personalmente.

## 3.3 Normalización de los datos

Por último, procedo a la __normalización__ de los datos filtrados. El paquete __edgeR__ se ocupa del análisis de la expresión diferencial más que de la cuantificación de los niveles de expresión. Es decir, se ocupa de los cambios relativos en los niveles de expresión entre las condiciones. Por esta razón, los problemas de normalización se plantean sólo en la medida en que los factores técnicos tienen efectos específicos en la muestra.

Hay dos factores técnicos que pueden afectar a los recuentos de lectura de expresión diferencial: 
  
  __La profundidad de secuenciación de cada muestra de ARN__. El paquete _edgeR_ ajusta automáticamente cualquier análisis de expresión diferencial para variar las profundidades de secuenciación, representadas por diferentes tamaños de librería.
  __La producción total de ARN por célula__. Esto suele ser importante cuando un pequeño número de genes se expresan en gran medida en una muestra, pero no en otra. Este efecto provoca que los genes altamente expresados consuman una proporción sustancial del tamaño total de la librería, lo que hace que los genes restantes no estén suficientemente muestreados en esa muestra.
  
Como el primer factor se corrige automáticamente con el paquete _edgeR_, debo corregir el segundo factor a través de la función __calcNormFactors__. Esta función encontrará un conjunto de factores de escala para los tamaños de las bibliotecas con el fin de minimizar los cambios de pliege entre las muestras para la mayoría de genes.
El método por defecto para calcular estos factores de escala utiliza una media recortada de valores M (TMM) entre cada par de muestras. La multiplicación del tamaño original de la librería por el factor de escala se llamará el __tamaño efectivo de la librería__, que sustituye al tamaño original de la librería en todos los análisis.

En este caso usaré el método por defecto, Trimmed Mean of M-values (TMM); ya que observando un poco los datos del archivo _counts_30_ se ve que el recuento total de lecturas depende en gran medida de unas pocas transcripciones altamente expresadas.

```{r Normalización de la muestra, echo=FALSE}
y <- calcNormFactors(y)
y$samples
```

Puede observarse que los factores de normalización han cambiado a través del último comando. Un factor de normalización inferior a uno indica que un pequeño número de genes de alto recuento monopoliza la secuencia, lo que hace que los recuentos de otros genes sean inferiores a lo que sería habitual dado el tamaño de la librería. Como resultado, el tamaño de la librería se reducirá, de forma análoga a la escalada de los recuentos al alza en esa librería. Por el contrario, un factor superior a uno aumenta el tamaño de la librería y equivale a reducir los recuentos.

El rendimiento del procedimiento de normalización de la TMM puede examinarse mediante gráficos de diferencia media o __plot MD__. Estos gráficos muestran la expresión media (media: eje x) frente a los cambios de logaritmo (diferencia: eje y).

El plot MD de pliegue se genera comparando la muestra 1:  _GTEX.111CU.0226.SM.5GZXC_  con una librería artificial construida a partir de la media de todas las demás muestras. He elegido la librería de la muestra 1 porque es una de las muestras con el factor de normalización más pequeño: 0.882. Para tener el ejemplo contrario, representaré igualmente la muestra _GTEX.13NZ9.1126.SM.5MR37_ la cual tiene uno de los factores de normalización más elevados: 1.156.

Si trazamos gráficos de diferencia media usando la función __plotMD__ para estas muestras, deberíamos ser capaces de ver el problema del sesgo de composición. Usaremos los recuentos del archivo _logcounts_, que han sido normalizados para el tamaño de la librería, pero no para el sesgo de composición y lo compararé con este mismo gráfico pero con los valores de _y_ después de la normalización. Lo ideal sería que en el _plotMD_ del objeto _y_ el grueso de los genes se centrara en un cambio de pliegue en torno a cero para ambas muestras, lo que indicaría que se ha eliminado con éxito cualquier sesgo de composición entre las librerías. 


```{r fig.cap="Plot MD para el logaritmo de los conteos, normalizados sólo para el tamaño de las librerías.", echo=FALSE, out.extra='', fig.height=5, fig.width=5, fig.align="center"}
par(mfrow=c(1,2))
plotMD(logcounts,column = 1)
abline(h=0, col="red", lty=2, lwd=2)
plotMD(logcounts,column = 24)
abline(h=0, col="red", lty=2, lwd=2)
```
```{r saveplotMD para logcounts, echo=FALSE, results='hide'}
#Guardo el plotMD en un archivo tiff en el directorio figures
tiff("./figures/plotMD_logcounts.tiff", res = 200, width = 4, height = 4, units = 'in')
par(mfrow=c(1,2))
plotMD(logcounts,column = 1)
abline(h=0, col="red", lty=2, lwd=2)
plotMD(logcounts,column = 24)
abline(h=0, col="red", lty=2, lwd=2)
dev.off()
```
En ambos casos se ve con claridad que los valores no se sitúan en torno a un cambio de pliegue de cero marcado por la línea roja; sino que las muestras están por debajo y por encima de un cambio de pliegeue de cero respectivamente. Ahora representaré el plotMD después de la normalización para el sesgo de composición con el _objeto y_.

```{r fig.cap="Plot MD para el objeto y, normalizado tanto para el tamaño de las librerías como para el sesgo de composición.", echo=FALSE, out.extra='', fig.height=5, fig.width=5, fig.align="center"}
par(mfrow=c(1,2))
plotMD(y,column = 1)
abline(h=0, col="red", lty=2, lwd=2)
plotMD(y,column = 24)
abline(h=0, col="red", lty=2, lwd=2)
```

```{r saveplotMD para y normalizado, echo=FALSE, results='hide'}
#Guardo el plotMD en un archivo tiff en el directorio figures
tiff("./figures/plotMD_yNormalizado.tiff", res = 200, width = 4, height = 4, units = 'in')
par(mfrow=c(1,2))
plotMD(y,column = 1)
abline(h=0, col="red", lty=2, lwd=2)
plotMD(y,column = 24)
abline(h=0, col="red", lty=2, lwd=2)
dev.off()
```

Ahora se aprecia que el grueso de genes para ambas muestras se sitúan en torno a un cambio de pliege en torno a cero, por lo que el sesgo se ha corregido con la normalización del _objeto y_.

Otro gráfico que se suele representar tras la normalización de los datos, es un __plot MDS__ donde se representan las similitudes relativas de las 30 muestras en función del tipo de infiltración existente en el tiroides. Las similitudes se cuantifican en forma de cambios de pliegue (log folg change) entre muestras.

En el _plot MDS_ la primera dimensión representa la magnitud del cambio biológico que mejor separa las muestras y, por lo tanto, el cambio biológico que representa la mayor proporción de variación de los datos. 

```{r fig.cap="Plot MDS para el análisis de distancias entre muestras", echo=FALSE, out.extra='', fig.height=5, fig.width=5, fig.align="center"}
colors_MDS <- rep(c("lightblue", "darkblue", "green"), 10)
points <- c(15,16,17)
plotMDS(y, col=colors_MDS[y$samples$group], pch=points[y$samples$group], main="Plot MDS para los tres grupos de infiltración")
legend('bottomright', legend=levels(y$samples$group), pch=points, col=colors_MDS)
```
```{r saveplotMDS, echo=FALSE, results='hide'}
#Guardo el plotMDS en un archivo tiff en el directorio figures
tiff("./figures/plotMDS.tiff", res = 200, width = 4, height = 4, units = 'in')
plotMDS(y, col=colors_MDS[y$samples$group], pch=points[y$samples$group], main="Plot MDS para los tres grupos de infiltración")
legend('bottomright', legend=levels(y$samples$group), pch=points, col=colors_MDS)
dev.off()
```

Existe una clara agrupación entre los tres grupos, lo que muestra un efecto según el tipo de infiltración. Esta tendencia era de esperar puesto que en este análisis es el único factor a tener en cuenta y puesto que el plotMDS es un plot muy similar al plot PCA, donde ya se obtuvieron los mismos resultados.

  -El grupo __ELI__ (cuadrado azul) esta mayoritariamente situado a la derecha del gráfico
  -El grupo __NIT__ (círculo azul) se concentra en la parte izquierda del gráfico
  -El grupo __SFI__ (triángulo verde) se acumula en la parte media-izquierda superior

Tan sólo hay una muestra del grupo _ELI_ que se sitúa en la parte del gráfico donde se concentra el grupo _NIT_. Podríamos considerar esta anomalía como un desviación aleatoria ya que solo es una muestra.

# 3. Identificación de genes diferencialmente expresados

## 3.1 Matriz de diseño

La matriz de diseño contiene los predictores para cada muestra; en la matriz se asigna un coeficiente a cada grupo. La matriz de diseño se crea a partir del _objeto y_ ya que contiene la información sobre el grupo experimental al que pertenece cada muestra. 
En este análisis, lo interesante son las diferencias entre los tres tipos de infiltración. Por lo tanto, creo una matriz de diseño utilizando el factor _tipo de infiltración_. La función __model.matrix__ permite crear la matriz de diseño de manera sencilla, en esta matriz se asignarán 1 para indicar que la muestra pertenece a dicho grupo experimental y cero en los otros dos grupos. 
La matriz de diseño se ha registrado en el directorio __results__ bajo el nombre _design.matrix_.

```{r Matriz de diseño, echo=FALSE}
# Estraigo los grupos experimentales del objeto y
grupos<- y$samples$group
design <- model.matrix(~0+grupos)
colnames(design) <- levels(grupos)
rownames(design)<- ShortName
design
```
```{r Registro de la matriz de diseño, include=FALSE}
write.csv(design, file = "./results/design.matrix.csv")
```

## 3.2 Estimación de la dispersión

El modelo probabilístico __Binomial Negativa__ es el elegido por el paquete __edgeR__ para modelar los datos de conteo. El primer paso será estimar la dispersión de cada tránscrito a partir de la variabilidad total para todos los genes.

Para experimentos con un solo factor, como en este caso (tipo de infiltración) donde se buscan comparaciones por pares entre grupos, el paquete __edgeR__ utiliza el método de máxima probabilidad condicional ajustada por cuantiles (qCML). 
El __método qCML__ es un enfoque clásico del paquete _edgeR_ que calcula la probabilidad condicionándose a los recuentos totales de cada etiqueta, y utiliza pseudocuentas después de ajustar los tamaños de las librerías. Es decir, primero se estima la dispersión común o variabilidad total (common dispersion) y luego se estima la  dispersión gen a gen (dispersion Tagwise). Para cada una de estas estimaciones existe una función propia; sin embargo, usaré la función _estimateDisp_ capaz de calcular las dos dispersiones a la vez.

Entonces estimo la dispersión del __modelo negativo binomial__ (NB) usando la función _estimateDisp_. La estimación se robustece contra los potenciales genes atípicos. Dicha función devuelve el objeto DGEList con entradas adicionales para las dispersiones NB estimadas para todos los genes, como el coeficiente biológico de variación de cada gen (BCV).

```{r Estimación de la dispersión, echo=FALSE}
require(edgeR)
# Calculo ambas dispersiones
y <- estimateDisp(y, design, robust=TRUE)
# Dispersión común
y$common.dispersion
# Dispersión gen a gen
head(y$tagwise.dispersion,10)
BCV<- sqrt(y$common.dispersion)
BCV
```

La estimación de la dispersión nos da una dispersión común de 0.24; además se muestra la dispersión de cada gen, la cual se ve que varía hacia arriba o hacia abajo con respecto a la dispersión común. El __coeficiente de variación biológica (BCV)__ se ha calculado a través de la raíz cuadrada de la dispersión común, obteniendo un coeficiente BCV de 48,8%. 

El coeficiente BCV también puede estimarse gráficamente a través de la función __plotBCV__ junto a las dispersiones calculadas anteriormente; de este modo puede comprobarse si la dispersión común representa realmente la dispersión existente entre los genes. Estos gráficos se obtienen al representar la raíz cuadrada de las dispersiones estimadas frente al logaritmo en base 2 de las lecturas por millón.

```{r fig.cap="Plot BCV para el cálculo del coeficiente de variación biológica (BCV) y el cálculo de la dispersión entre las muestras.", echo=FALSE, out.extra='', fig.height=5, fig.width=5, fig.align="center"}
plotBCV(y)
```

El gráfico BCV representa las dispersiones estimadas gen a gen (dispersión tagwise) a partir de la dispersión común, representada por la línea roja. Cada punto en el gráfico representa un gen y la línea azul muestra la tendencia de variación biológica con el aumento de lecturas. 
El gráfico indica que el coeficiente BCV es entorno a un 50%, el cual coincide con el coeficiente BCV calculado a través de la raíz cuadrada de la dispersión negativa binomial. La variación biológica entre las muestras del mismo grupo influye en el número de genes que se expresan diferencialmente en dicho grupo. Es decir, cuanto mayor sea la variación entre los tres grupos con respecto a la variación entre grupos, más fácil será detectar los genes que cambian su expresión.

De manera general, un valor óptimo del coeficiente de variación biológico común entre 0.2 y 0.4 favorecería la detección de genes diferencialmente expresados; en este caso tenemos un coeficiente de 0.49, ligeramente superior al valor óptimo. Esto podría llevarnos a seleccionar menos genes DE de los que realmente hay.

```{r saveplotBCV, echo=FALSE, results='hide'}
#Guardo el plotBCV en un archivo tiff en el directorio figures
tiff("./figures/plotBCV.tiff", res = 200, width = 4, height = 4, units = 'in')
plotBCV(y)
dev.off()
```

Luego paso al análisis de expresión diferencial estimando las dispersiones de cuasi-probabilidad (QL) alrededor de la tendencia de dispersión usando la función _glmQLFit_. Esta función devuelve un objeto DGEGLM al que llamo __fit__ que contiene los valores estimados de los coeficientes GLM para cada gen, así como la tendencia de dispersión de la media ajustada de QL, las estimaciones de QL ajustadas y los grados de libertad previos (df). 
Se recomienda utilizar el argumento "robust=TRUE" ya que identifica los genes que son atípicos de la tendencia de dispersión media NB.

```{r dispersiones QL, echo=FALSE}
fit <- glmQLFit(y, design, robust=TRUE) 
head(fit$coefficients)
```

Estos pueden ser visualizados con la función _plotQLDisp_.

```{r fig.cap="Plot QLDisp para el cálculo genes atípicos a la tendencia de dispersión media binomial negativa.", echo=FALSE, out.extra='', fig.height=5, fig.width=5, fig.align="center"}
plotQLDisp(fit)
```

```{r saveplotQLDisp, echo=FALSE, results='hide'}
#Guardo el plotQLDisp en un archivo tiff en el directorio figures
tiff("./figures/plotQLDisp.tiff", res = 200, width = 4, height = 4, units = 'in')
plotQLDisp(fit)
dev.off()
```

## 3.3 Expresión diferencial

En este estudio hay un interés en comparar los tres tipos de grupos entre sí, por lo que debo hacer __tres contrastes__:

  -SFI vs NIT
  -ELI vs NIT
  -ELI vs SFI
  
En un primer paso, haré los tres contrastes por separado para buscar diferencias entre los dos grupos comparados en cada contraste. En el paquete __edgeR__ la función __exactTest__ realiza el test exacto binomial negativo. En esta función se puede hacer cada contraste por separado, comparando a cada vez dos grupos entre sí para realizar la prueba en cada fila de datos. La función __topTags__ nos devolverá una tabla con los genes DE más significativos para ese contraste.

**Contraste ELI vs NIT**

Realización del test exacto negativo y obtención de la tabla con les genes DE más significativos.

```{r contraste ELIvsNIT, echo=FALSE}
ELIvsNIT<- exactTest(y, pair = c("ELI", "NIT"))
topTags(ELIvsNIT)
```

El siguiente paso es seleccionar los genes DE para el contraste ELI vs NIT. Obtenemos como resultado un total de 2748 genes con un valor FDR inferior al nivel de significación ($\alpha=0.05$). De estos genes DE, 1954 disminuyen su expresión y 794 están sobreexpresados.

```{r decideTest ELIvsNIT, echo=FALSE}
ELIvsNIT_test<-decideTestsDGE(ELIvsNIT)
summary(ELIvsNIT_test)
```

Por último, represento gráficamente los resultados con la función __plotSmear__. Este tipo de gráfico se basa en la representación del logaritmo en base 2 del fold- change (logFC) correspondiente a cada gen frente a la media del logaritmo en base 2 de los conteos por millón. Los puntos se colorearán de rojo si el valor p ajustado es inferior a 0,01; es decir, los puntos rojos son los genes diferencialmente expresados. Las líneas azules horizontales muestran cambios cuádruples.

```{r fig.cap="PlotSmear para el contraste ELI vs NIT.", echo=FALSE, out.extra='', fig.height=5, fig.width=5, fig.align="center"}
detags_ELIvsNIT <- rownames(y)[as.logical(ELIvsNIT_test)]
plotSmear(ELIvsNIT, de.tags=detags_ELIvsNIT, main="plotSmear contraste ELIvsNIT")
abline(h=c(-1,1), col="blue")
```
```{r saveplotSmear ELIvsNIT, echo=FALSE, results='hide'}
#Guardo el plotSmear ELIvsNIT en un archivo tiff en el directorio figures
tiff("./figures/plotSmear_ELIvsNIT.tiff", res = 200, width = 4, height = 4, units = 'in')
plotSmear(ELIvsNIT, de.tags=detags_ELIvsNIT, main="plotSmear contraste ELIvsNIT")
abline(h=c(-1,1), col="blue")
dev.off()
```

**Contraste SFI vs NIT**

Realización del test exacto negativo y obtención de la tabla _topTags_.

```{r contraste SFIvsNIT, echo=FALSE}
SFIvsNIT<- exactTest(y, pair = c("SFI", "NIT"))
topTags(SFIvsNIT)
```

Selección de genes DE para el contraste SFI vs NIT. Para este contraste apenas se encuentras genes DE, tan sólo 41 genes de los cuales 39 disminuyen su expresión y 2 la aumentan.

```{r decideTest SFIvsNIT, echo=FALSE}
SFIvsNIT_test<-decideTestsDGE(SFIvsNIT)
summary(SFIvsNIT_test)
```

Representación gráfica con __plotSmear__. Al haber tan pocos genes DE con respecto al total, los puntos rojos apenas se aprecian visualmente.

```{r fig.cap="PlotSmear para el contraste SFI vs NIT.", echo=FALSE, out.extra='', fig.height=5, fig.width=5, fig.align="center"}
detags_SFIvsNIT <- rownames(y)[as.logical(SFIvsNIT_test)]
plotSmear(SFIvsNIT, de.tags=detags_SFIvsNIT, main="plotSmear contraste SFIvsNIT")
abline(h=c(-1,1), col="blue")
```
```{r saveplotSmear SFIvsNIT, echo=FALSE, results='hide'}
#Guardo el plotSmear SFIvsNIT en un archivo tiff en el directorio figures
tiff("./figures/plotSmear_SFIvsNIT.tiff", res = 200, width = 4, height = 4, units = 'in')
plotSmear(SFIvsNIT, de.tags=detags_SFIvsNIT, main="plotSmear contraste SFIvsNIT")
abline(h=c(-1,1), col="blue")
dev.off()
```

**Contraste ELI vs SFI**

Realización del test exacto negativo y obtención de la tabla con los genes DE.

```{r contraste ELIvsSFI, echo=FALSE}
ELIvsSFI<- exactTest(y, pair = c("ELI", "SFI"))
topTags(ELIvsSFI)
```

Selección de genes DE para el contraste ELI vs SFI. Para este contraste un total de 2470 genes tiene un FDR inferior al nivel de significación. De ellos 686 aumentan su expresión y 1784 la disminuyen. 

```{r decideTest ELIvsSFI, echo=FALSE}
ELIvsSFI_test<-decideTestsDGE(ELIvsSFI)
summary(ELIvsSFI_test)
```

Representación gráfica con __plotSmear__. En este contraste la mayoría de los puntos rojos están bajo un logFC negativo en el eje Y porque hay muchos más genes DE downregulated.

```{r fig.cap="PlotSmear para el contraste ELI vs SFI.", echo=FALSE, out.extra='', fig.height=5, fig.width=5, fig.align="center"}
detags_ELIvsSFI <- rownames(y)[as.logical(ELIvsSFI_test)]
plotSmear(ELIvsSFI, de.tags=detags_ELIvsSFI, main="plotSmear contraste ELIvsSFI")
abline(h=c(-1,1), col="blue")
```
```{r saveplotSmear ELIvsSFI, echo=FALSE, results='hide'}
#Guardo el plotSmear ELIvsSFI en un archivo tiff en el directorio figures
tiff("./figures/plotSmear_ELIvsSFI.tiff", res = 200, width = 4, height = 4, units = 'in')
plotSmear(ELIvsSFI, de.tags=detags_ELIvsSFI, main="plotSmear contraste ELIvsSFI")
abline(h=c(-1,1), col="blue")
dev.off()
```

Una vez tenemos la lista de genes DE en cada contraste, podemos buscar los genes comunes a los tres contrastes con la función __intersect__.

```{r Selección de genes DE comunes a los tres contrastes, echo=FALSE}
comunes<- intersect(intersect(rownames(topTags(ELIvsNIT)), rownames(topTags(SFIvsNIT))), rownames(topTags(ELIvsSFI)))
length(comunes)
```

No hay ningún gen DE común para los tres contrastes. Voy a verificar si hay genes DE comunes entre dos contrastes.

```{r Genes DE comunes entre los contrastes ELIvsNIT y SFIvsNIT, echo=FALSE}
comunes_1vs2<-intersect(rownames(topTags(ELIvsNIT)), rownames(topTags(SFIvsNIT)))
length(comunes_1vs2)
print(comunes_1vs2)
```

Existten 3 genes DE comunes para los contrastes ELIvsNIT y SFIvsNIT. Estos genes corresponden a las filas: 16760, 6717 y 3379; si extraemos estas filas en el archivo _counts_ obtenemos el identificador ENSEMBL

```{r Identificación de los genes DE comunes a los contrastes ELIvsNIT y SFIvsNIT, echo=FALSE}
counts$X[c(16760, 6717, 3379)]
```

Pasamos a la siguiente pareja de contrastes.

```{r Genes DE comunes entre los contrastes ELIvsNIT y ELIvsSFI, echo=FALSE}
comunes_1vs3<-intersect(rownames(topTags(ELIvsNIT)), rownames(topTags(ELIvsSFI)))
length(comunes_1vs3)
print(comunes_1vs3)
```

Buscamos el identificador ENSEMBL para estos siete genes.

```{r Identificación de los genes DE comunes a los contrastes ELIvsNIT y ELIvsSFI, echo=FALSE}
counts$X[c(49043, 42101, 48230, 31449, 45681, 3388, 49407)]
```

La última pareja de contrastes a comparar es SFIvsNIT con ELIvsSFI.

```{r Genes DE comunes entre los contrastes SFIvsNIT y ELIvsSFI, echo=FALSE}
comunes_2vs3<-intersect(rownames(topTags(SFIvsNIT)), rownames(topTags(ELIvsSFI)))
length(comunes_2vs3)
print(comunes_2vs3)
```

No hay ningún gen DE común para esta pareja de contrastes.

# 4. Anotación de los resultados

El proceso de anotación consiste en relacionar los identificadores _ENTREZID_ de la primera columna de las tablas _topTags_ con información más fácil de manejar como el _Gene Symbol_ o _Gene Name_. El símbolo del gen y su descripción se añadirán a los resultados de las tablas gracias al paquete de anotación del genoma humano __org.Hs.eg.db__, el cual permite asociar los identificadores _ENTREZID_ de la primera columna de las tablas con el nombre y la descripción de los genes.

```{r Instalación paquete genoma humano, include=FALSE}
BiocManager::install("org.Hs.eg.db")
```

```{r Registro de los resultados de los topTags, echo=FALSE}
results_ELIvsNIT <- as.data.frame(topTags(ELIvsNIT, n= Inf))
results_SFIvsNIT <- as.data.frame(topTags(SFIvsNIT, n= Inf))
results_ELIvsSFI <- as.data.frame(topTags(ELIvsSFI, n= Inf))
```

Anotación de los genes seleccionados con el genoma humano __org.Hs.eg.db__ como referencia.

```{r Anotación de los genes, echo=FALSE}
library(org.Hs.eg.db)
ann_ELIvsNIT <- select(org.Hs.eg.db,keys=rownames(results_ELIvsNIT),columns=c("ENTREZID","SYMBOL","GENENAME"))
ann_SFIvsNIT <- select(org.Hs.eg.db,keys=rownames(results_SFIvsNIT),columns=c("ENTREZID","SYMBOL","GENENAME"))
ann_ELIvsSFI <- select(org.Hs.eg.db,keys=rownames(results_ELIvsSFI),columns=c("ENTREZID","SYMBOL","GENENAME"))
```

Añado el resultados de las anotaciones a la tabla _topTags_ de los genes seleccionados.

```{r Unión de la anotación a los resultados, echo=FALSE}
results.annotated_ELIvsNIT <- cbind(results_ELIvsNIT, ann_ELIvsNIT)
results.annotated_SFIvsNIT <- cbind(results_SFIvsNIT, ann_SFIvsNIT)
results.annotated_ELIvsSFI <- cbind(results_ELIvsSFI, ann_ELIvsSFI)
```

Guardo los archivos en un archivo excel para cada contraste; de este modo las anotaciones de los genes seleccionados en cada contraste están disponibles en el directorio __results__.

```{r Registro de los resultados de anotación, include=FALSE}
write.csv(results.annotated_ELIvsNIT,file="./results/anotaciones_ELIvsNIT.csv",row.names=FALSE)
write.csv(results.annotated_SFIvsNIT,file="./results/anotaciones_SFIvsNIT.csv",row.names=FALSE)
write.csv(results.annotated_ELIvsSFI,file="./results/anotaciones_ELIvsSFI.csv",row.names=FALSE)
```

Si se observan los tres archivos excel, se puede ver que para muchos genes no hay anotación disponible aún. En ese caso, el valor de las columnas _Symbol_ y _Genename_ será NA; una buena continuación de este estudio sería hacer la __anotación de novo__ de estos genes para los que aún no existe anotación.

Los resultados de las tablas de selección junto a las anotaciones se pueden visualizar a través de un gráfico llamado __volcano plot__. En este gráfico se representa en el eje de abscisas los cambios de expresión en escala logarítmica; mientras que en el eje de ordenadas se representa la significancia del gen a través del estadístico B en escala logarítmica. En este caso se representan los cuatro primeros genes más diferencialmente expresados de cada tabla.

Los tres volcanos se recogen en el archivo _Volvanos.pdf_ del directorio __figures__.

```{r fig.cap="Volcanoplot para el contraste ELI vs NIT.", echo=FALSE, out.extra='', fig.height=5, fig.width=5, fig.align="center"}
signif_ELIvsNIT <- -log10(results.annotated_ELIvsNIT$FDR)
plot(results.annotated_ELIvsNIT$logFC,signif_ELIvsNIT,pch=16, main= "Genes diferencialmente expresados en ELIvsNIT", xlab= "logFC", ylab= "Significancia")
points(results.annotated_ELIvsNIT[detags_ELIvsNIT,"logFC"],-log10(results.annotated_ELIvsNIT[detags_ELIvsNIT,"FDR"]),pch=16,col="red")
```


```{r fig.cap="Volcanoplot para el contraste SFI vs NIT.", echo=FALSE, out.extra='', fig.height=5, fig.width=5, fig.align="center"}
signif_SFIvsNIT <- -log10(results.annotated_SFIvsNIT$FDR)
plot(results.annotated_SFIvsNIT$logFC,signif_SFIvsNIT,pch=16, main= "Genes diferencialmente expresados en SFIvsNIT", xlab= "logFC", ylab= "Significancia")
points(results.annotated_SFIvsNIT[detags_SFIvsNIT,"logFC"],-log10(results.annotated_SFIvsNIT[detags_SFIvsNIT,"FDR"]),pch=16,col="red")
```

```{r fig.cap="Volcanoplot para el contraste ELI vs SFI.", echo=FALSE, out.extra='', fig.height=5, fig.width=5, fig.align="center"}
signif_ELIvsSFI <- -log10(results.annotated_ELIvsSFI$FDR)
plot(results.annotated_ELIvsSFI$logFC,signif_ELIvsSFI,pch=16, main= "Genes diferencialmente expresados en ELIvsSFI", xlab= "logFC", ylab= "Significancia")
points(results.annotated_ELIvsSFI[detags_ELIvsSFI,"logFC"],-log10(results.annotated_ELIvsSFI[detags_ELIvsSFI,"FDR"]),pch=16,col="red")
```

```{r Guardar los plots en un archivo pdf, include=FALSE}
pdf("figures/Volcanos.pdf")
plot(results.annotated_ELIvsNIT$logFC,signif_ELIvsNIT,pch=16, main= "Genes diferencialmente expresados en ELIvsNIT", xlab= "logFC", ylab= "Significancia")
points(results.annotated_ELIvsNIT[detags_ELIvsNIT,"logFC"],-log10(results.annotated_ELIvsNIT[detags_ELIvsNIT,"FDR"]),pch=16,col="red")
plot(results.annotated_SFIvsNIT$logFC,signif_SFIvsNIT,pch=16, main= "Genes diferencialmente expresados en SFIvsNIT", xlab= "logFC", ylab= "Significancia")
points(results.annotated_SFIvsNIT[detags_SFIvsNIT,"logFC"],-log10(results.annotated_SFIvsNIT[detags_SFIvsNIT,"FDR"]),pch=16,col="red")
plot(results.annotated_ELIvsSFI$logFC,signif_ELIvsSFI,pch=16, main= "Genes diferencialmente expresados en ELIvsSFI", xlab= "logFC", ylab= "Significancia")
points(results.annotated_ELIvsSFI[detags_ELIvsSFI,"logFC"],-log10(results.annotated_ELIvsSFI[detags_ELIvsSFI,"FDR"]),pch=16,col="red")
dev.off()
```

Para reforzar la visualización gráfica de la anotación, voy a representar el gen DE más significativo de cada lista para el que exista anotación y así poder verificar los niveles de expresión de este gen concreto en cada grupo. Para mirar la expresión conjunta de cada gen seleccionado en los tres grupos utilizaré un gráfico de barras con los valores de expresión logarítmica normalizados en el objeto __y__ (y$counts).

Para la lista _topTags_ de genes DE del contraste __ELIvsNIT__ el gen escogido es el correspondiente al número 6717, el cual corresponde al gen SRI. Para el contraste __ELIvsSFI__ será el gen cuyo _ENTREZID_ es 3388, que corresponde al gen ICR1; 
y para el contraste __SFIvsNIT__ el identificador a representar es el 6708, que hace referencia al gen SPTA1.

```{r fig.cap="Gráfico de barras de la expresión individual de los genes SRI, ICR1 y SPTA1.", echo=FALSE, out.extra='', fig.height=5, fig.width=5, fig.align="center"}
library(RColorBrewer)
par(mfrow=c(1,3))
normCounts <- y$counts
nice.col <- brewer.pal(6,name="Dark2")
stripchart(normCounts["6717",]~group,vertical=TRUE,las=2,cex.axis=0.8,pch=16,cex=1.3,col=nice.col,method="jitter",ylab="Normalised log2 expression",main="    SRI")
stripchart(normCounts["3388",]~group,vertical=TRUE,las=2,cex.axis=0.8,pch=16,cex=1.3,col=nice.col,method="jitter",ylab="Normalised log2 expression",main="    ICR1")
stripchart(normCounts["6708",]~group,vertical=TRUE,las=2,cex.axis=0.8,pch=16,cex=1.3,col=nice.col,method="jitter",ylab="Normalised log2 expression",main="    SPTA1")
```


El resultado común en ambos contraste es que los tres genes analizados de manera individual tiene su mayor nivel de expresión en el __grupo ELI__ que corresponde con _extensos filtrados linfoides_ y la expresión más moderada se encuentra en el grupo __NIT__ que representa _tejidos no infiltrados_.
Los gráficos se encuentran en el directorio __figures__ bajo el nombre _Stripchart_.

```{r Guardar los Stripchart en un archivo tiif, include=FALSE}
library(RColorBrewer)
tiff("figures/Stripcharts.tiff")
par(mfrow=c(1,3))
normCounts <- y$counts
nice.col <- brewer.pal(6,name="Dark2")
stripchart(normCounts["6717",]~group,vertical=TRUE,las=2,cex.axis=0.8,pch=16,cex=1.3,col=nice.col,method="jitter",ylab="Normalised log2 expression",main="    SRI")
stripchart(normCounts["3388",]~group,vertical=TRUE,las=2,cex.axis=0.8,pch=16,cex=1.3,col=nice.col,method="jitter",ylab="Normalised log2 expression",main="    ICR1")
stripchart(normCounts["6708",]~group,vertical=TRUE,las=2,cex.axis=0.8,pch=16,cex=1.3,col=nice.col,method="jitter",ylab="Normalised log2 expression",main="    SPTA1")
dev.off()
```

Para completar el proceso de anotación, añadiré las localizaciones genómicas de los genes DE seleccionados en cada contraste. Las localizaciones genómicas se encuentran en el paquete __TxDb.Hsapiens.UCSC.hg19.knownGene__ para el ser humano en este caso, pero existen otros paquetes correspondientes a las localizaciones genómicas de otros organismo. Todos los paquetes disponibles pueden consultarse en la web de __Bioconductor__.

El primer paso es descargar el paquete que contiene las localizaciones genómicas para el _Homo Sapiens_.

```{r Descarga del paquete de localizaciones genómicas, include=FALSE}
BiocManager::install("TxDb.Hsapiens.UCSC.hg19.knownGene")
```

Para ahorrarme escribir el largo nombre del paquete, lo guardaré en una variable llamada __tx__ y, además, compruebo las columnas disponibles en el paquete para escoger algunas de ellas como información de la posición de los genes de estudio.

```{r Creación del objeto tx y verificación de las columnas disponibles, include=FALSE}
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
tx <- TxDb.Hsapiens.UCSC.hg19.knownGene
columns(tx)
```

Para seguir con el ejemplo anterior, escogeré de nuevo los tres genes representados en el _Stripchart_. En esta ocasión creo una variable llamada __posiciones__ donde se guardan las siguientes columnas: 

    -GENEID: identificador numérico del gen
    -EXONCHROM: identificador del cromosoma en el genoma
    -EXONSTART: coordenada de inicio del exon del gen en el genoma
    -EXONEND: coordenada de fin del exon del gen en el genoma
    
```{r}
library(GenomicFeatures)
keys<- c("6717","3388","6708")
posiciones<- select(tx, keys=keys ,columns=c("EXONCHROM","EXONSTART","EXONEND"), keytype = "GENEID")
```

Para guardar los resultados, creo un data frame con __sólo los genes DE__. Los resultados se encuentran en forma de archivo excel en el directorio __results__ bajo los nombres de _sigGenes_.

De los 22990 genes iniciales, son significativos para cada contraste:

  __ELIvsNIT__: 2748 genes DE.
  __ELIvsSFI__: 2470 genes DE.
  __SFIvsNIT__: 41 genes DE.

```{r Dataframe genes DE, include=FALSE}
sigGenes_ELIvsNIT <- results.annotated_ELIvsNIT[detags_ELIvsNIT,]
sigGenes_ELIvsSFI <- results.annotated_ELIvsSFI[detags_ELIvsSFI,]
sigGenes_SFIvsNIT <- results.annotated_SFIvsNIT[detags_SFIvsNIT,]
```

```{r Registro de los resultados de los genes DE, echo=FALSE}
write.csv(sigGenes_ELIvsNIT,file="./results/sigGenes_ELIvsNIT.csv",row.names=FALSE)
write.csv(sigGenes_SFIvsNIT,file="./results/sigGenes_SFIvsNIT.csv",row.names=FALSE)
write.csv(sigGenes_ELIvsSFI,file="./results/sigGenes_ELIvsSFI.csv",row.names=FALSE)
```

# 5. Búsqueda de patrones de expresión y agrupación de las muestras

Para poder llevar a cabo un contraste entre más de dos grupos, recurrimos al __análisis unidireccional de varianza (ANOVA)__ para cada gen. Para ello, debemos crear primero una matriz de contrastes, donde cada columna representa un contraste entre dos grupos de interés. La matriz de contrastes se crea a partir de la función _makeContrasts_ y reune los tres mismos contrastes trabajados anteriormente.
La matriz de contraste __con__ se ha registrado en el directorio __results__ como _cont.matrix_.

```{r Matriz de contrastes, echo=FALSE}
con <- makeContrasts(
SFIvsNIT = SFI - NIT,
ELIvsNIT = ELI - NIT,
ELIvsSFI = ELI - SFI, levels=design)
print(con)
```
```{r Guardar la amtriz de contraste, include=FALSE}
write.csv(con, file="./results/cont.matrix.csv")
```

La función _glmQLFTest_ lleva a cabo la prueba de cuasi-probabilidad (QL) del test F que se aplica para identificar los genes que se expresan diferencialmente entre los tres grupos. Esto combina las tres comparaciones por pares en un solo estadístico F y un p-valor. La lista de genes más significativos puede obtenerse con la función _topTags_.
Anteriormente había obtenido la lista _topTags_ para cada contraste individualmente y ahora he creado una única tabla donde se recogen los genes DE más significativos en los tres contrastes. Esta tabla se encuentra en el directorio __results__ como un archivo excel bajo el nombre _topTags_anov_.

```{r Identificación de genes diferencialmente expresados, echo=FALSE}
anov <- glmQLFTest(fit, contrast = con)
topTags_anov<-topTags(anov)
topTags_anov
```

```{r Registro de la tabla topTags, include=FALSE}
write.csv(topTags_anov, file="./results/topTags_anov.csv")
```

El número total de genes diferencialmente expresados en cada grupo que tengan un FDR del 5% puede ser examinado con los tests de decisión gracias a la función _decideTests_.

```{r Resumen decideTests, echo=FALSE}
genes.de <- decideTests(anov, p.value=0.05)
summary(genes.de)
```

El resultado anterior muestra que de los 22990 genes analizados (es el número de genes seleccionados tras la filtración), 2277 genes cambian su expresión.

# 6.Análisis de significación biológica

El análisis de enriquecimiento biológico (GEA) sirve para interpretar los resultados de la expresión diferencial en un contexto biológico. Su objetivo es identificar las funciones, rutas metabólicas o procesos biológicos donde intervienen los genes más diferencialmente expresados.

En este caso, se identificarán los términos GO que están sobrerrepresentados en los tres grupos: ELI, SFI y NIT. Esto es posible aplicando la función __goana__ a los resultados de expresión diferencial de estas comparaciones. Con la función __topGo__ obtendremos una tabla con los 20 términos GO más enriquecidos en los tres grupos. Esta tabla está registrada en el directorio __results__ como _topGO_.

```{r Instalación del paquete GO.db, include=FALSE}
BiocManager::install("GO.db")
```

```{r Gene Set Enrichment Analysis, include=FALSE}
require(GO.db)
qlf <- glmQLFTest(fit, contrast=con)
go <- goana(qlf, species = "Hs")
```

```{r topTable GEO para los términos GO más enriquecidos, echo=FALSE}
topGo<-topGO(go, n=20)
print(topGo)
```

```{r Registro de la tabla topGo, include=FALSE}
write.csv(topGo, file="./results/topGo.csv")
```

Los nombres de las filas de la salida son los identificadores universales de los términos GO, con un término por fila. Para entender bien el resultado obtenido, haré una descripción de lo que representa cada columna de la tabla _topGo_:

  __Term__: Nombra los términos GO
  __Ont__: Conjunto de dominios o tipos de términos
              -BP: Proceso Biológico
              -CC: Componente Celular
              -MF: Función Molecular
  __N__: Número total de genes que se anotan en cada término GO
  __DE__: Número de genes correspondiente a dicho término GO que están diferencialmente 
          expresados
  __P.DE__: Contiene los valores p para la sobrerrepresentación del término GO en el conjunto de genes
  
La tabla de salida está ordenada por orden ascendente del p-valor, es decir los términos más afectados están al inicio de la tabla.

## 6.1 Probando conjuntos de genes (Gene Set Testing)

Para profundizar un poco más en el análisis de enriquecimiento biológico, se puede utilizar la prueba del conjunto de genes de rotación: __ROAST__. Dado un conjunto de genes, podemos probar si la mayoría de los genes del conjunto están diferencialmente expresados a través del contraste o contrastes de interés. Es útil cuando el conjunto especificado contiene todos los genes involucrados en alguna vía o proceso.

Para este caso concreto, me interesaré en dos términos GO relacionados con la actividad del receptor; puesto que son dos términos obtenidos en la tabla anterior. Cada término se usará para definir un conjunto que contenga todos los genes que están anotados con ese término.

```{r Selección de los conjuntos de genes, include=FALSE}
library(GO.db)
cyt.go <- c("GO:0004896", "GO:0004879")
term <- select(GO.db, keys=cyt.go, columns="TERM") 
```

Construyo una lista de dos componentes, cada uno de los cuales es un vector de las identificaciones __Entrez__ de los genes para todos los genes anotados con uno de los términos GO. Luego convertimos las IDs de los genes en índices de fila del objeto _fit_ usando la función __ids2indices__.

```{r Instalación de GenomicFeatures, include=FALSE}
BiocManager::install("GenomicFeatures")
```

```{r Lista de componentes de los GO seleccionados, include=FALSE}
require(GenomicFeatures)
Rkeys(org.Hs.egGO2ALLEGS) <- cyt.go
ind <- ids2indices(as.list(org.Hs.egGO2ALLEGS), row.names(fit))
```

Procedo a ejecutar el test __ROAST__ en los conjuntos de genes definidos para el contraste de interés. Supongamos que la comparación de interés es entre los grupos ELI (Extensive lymphoid infiltrates) y NIT (not infiltrated tissues). Usamos la función __fry__ para probar múltiples conjuntos de genes.

```{r test ROAST, echo=FALSE}
con_ELIvsNIT <- makeContrasts(ELI-NIT, levels=design)
fr <- fry(y, index=ind, design=design, contrast=con_ELIvsNIT)
fr
```

Cada fila del objeto _fr_ corresponde a un único conjunto de genes; en este caso de cada término GO. Al igual que con la tabla _go_, explicaré cada columna de la tabla __fr__ para entenderla mejor:

  __NGenes__: Número de genes en cada conjunto de genes
  __Direction__: Es la dirección neta del cambio, esta se determina a partir de la importancia de los cambios en cada dirección
  __PValue__: Sirve para determinar si la mayoría de los genes del conjunto se expresan diferencialmente en la dirección especificada
  __FDR__: Este estadístico se calcula a partir de los correspondientes p-valores en todos los conjuntos
  __PValue.Mixed__: Prueba la expresión diferencial en cualquier dirección

Para finalizar, se puede representar visualmente el resultado anterior a través de la función __barcodeplot__. Esta función permite visualizar los resultados de cualquier conjunto presente en la tabla _fr_; en este caso, he escogido el conjunto de genes definido por _GO:0004896_.

Los genes están representados por barras y se clasifican de izquierda a derecha disminuyendo el cambio de pliegue, formando así el patrón de código de barras. La línea sobre el código de barras muestra el enriquecimiento local relativo de las barras verticales en cada parte del gráfico. Este gráfico en particular sugiere que la mayoría de los genes de este conjunto están down-regulated en el grupo ELI en comparación con el grupo NIT.
El gráfico lo he guardado en el directorio __figures__ como _Barcodeplot_.

```{r fig.cap="BarcodePlot ELI vs NIT.", echo=FALSE, out.extra='', fig.height=5, fig.width=5, fig.align="center"}
res_ELIvsNIT <- glmQLFTest(fit, contrast=con_ELIvsNIT)
barcodeplot(res_ELIvsNIT$table$logFC, ind[[1]], main=names(ind)[1])
```

```{r Registro del barcodeplot para el término GO:0004896, include=FALSE}
tiff("./figures/Barcodeplot.tiff", res = 200, width = 4, height = 4, units = 'in')
barcodeplot(res_ELIvsNIT$table$logFC, ind[[1]], main=names(ind)[1])
dev.off()
```

# 7. Setup

El análisis se condujo en la versión de R:

```{r SessionInfo, echo=FALSE}
sessionInfo()
```


